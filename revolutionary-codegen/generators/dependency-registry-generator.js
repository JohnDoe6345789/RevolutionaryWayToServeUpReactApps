#!/usr/bin/env node

/**
 * DependencyRegistryGenerator - Revolutionary dependency management system
 * Generates enhanced class registry with dependency enforcement and circular dependency detection
 * 
 * üöÄ Revolutionary Features:
 * - Automatic dependency validation during registration
 * - Circular dependency detection and prevention
 * - Lazy loading and caching of dependencies
 * - Singleton pattern enforcement
 * - Dependency graph visualization
 * - Runtime dependency injection
 */

const fs = require('fs');
const path = require('path');
const BaseCodegen = require('../base/base-codegen');

class DependencyRegistryGenerator extends BaseCodegen {
  constructor(options = {}) {
    super({
      ...options,
      outputDir: options.outputDir || './generated-project',
      enableInnovations: options.enableInnovations !== false
    });
    
    this.specification = options.specification || null;
    this.dependencyConfig = options.dependencies || {};
    this.dependencyGraph = new Map();
    this.circularDependencies = [];
    this.registrationOrder = [];
    this.cache = new Map();
    this.singletons = new Map();
  }

  /**
   * Initialize dependency registry generator
   * @returns {Promise<DependencyRegistryGenerator>} Initialized generator
   */
  async initialize() {
    await super.initialize();
    
    this.log('üîó Initializing Dependency Registry Generator...', 'info');
    
    // Load specification if provided
    if (this.options.specPath && !this.specification) {
      await this.loadSpecification();
    }
    
    // Initialize dependency configuration
    this.initializeDependencyConfig();
    
    // Build dependency graph
    await this.buildDependencyGraph();
    
    // Detect circular dependencies
    await this.detectCircularDependencies();
    
    this.log('‚úÖ Dependency Registry Generator initialized', 'success');
    return this;
  }

  /**
   * Generate dependency registry system
   * @param {Object} results - Generation results object
   * @returns {Promise<void>}
   */
  async generate(results) {
    this.log('üîó Generating revolutionary dependency registry...', 'info');
    
    try {
      // Generate core registry class
      await this.generateRegistryClass();
      
      // Generate dependency manager
      await this.generateDependencyManager();
      
      // Generate dependency validator
      await this.generateDependencyValidator();
      
      // Generate circular dependency detector
      await this.generateCircularDependencyDetector();
      
      // Generate dependency injector
      await this.generateDependencyInjector();
      
      // Generate dependency graph visualizer
      if (this.shouldGenerateDependencyGraph()) {
        await this.generateDependencyGraphVisualizer();
      }
      
      // Generate registry utilities
      await this.generateRegistryUtilities();
      
      // Generate registration system
      await this.generateRegistrationSystem();
      
      // Generate caching system
      if (this.shouldEnableCaching()) {
        await this.generateCachingSystem();
      }
      
      // Generate singleton manager
      if (this.shouldUseSingletonPattern()) {
        await this.generateSingletonManager();
      }
      
      // Trigger innovation features
      this.triggerInnovation('dependencyRegistryGenerated', { 
        dependencies: this.dependencyGraph.size,
        circularDeps: this.circularDependencies.length,
        caching: this.shouldEnableCaching(),
        singleton: this.shouldUseSingletonPattern()
      });
      
    } catch (error) {
      this.log(`‚ùå Dependency registry generation failed: ${error.message}`, 'error');
      throw error;
    }
  }

  /**
   * Generate main registry class
   * @returns {Promise<void>}
   */
  async generateRegistryClass() {
    const content = `/**
 * üîó Revolutionary Dependency Registry
 * Enterprise-grade dependency management with validation and circular dependency detection
 * 
 * @generated by RevolutionaryCodegen
 */

class DependencyRegistry {
  constructor() {
    this.dependencies = new Map();
    this.instances = new Map();
    this.dependencyGraph = new Map();
    this.registrationOrder = [];
    this.singletons = new Map();
    this.cache = new Map();
    this.validators = new DependencyValidator();
    this.circularDetector = new CircularDependencyDetector();
    this.injector = new DependencyInjector();
    
    // Configuration
    this.config = {
      enforceDependencies: ${this.dependencyConfig.enforceDependencies !== false},
      autoRegister: ${this.dependencyConfig.autoRegister !== false},
      enableCaching: ${this.shouldEnableCaching()},
      singletonPattern: ${this.shouldUseSingletonPattern()},
      lazyLoading: ${this.shouldEnableLazyLoading()}
    };
  }

  /**
   * Register a dependency with validation
   * @param {string} name - Dependency name
   * @param {Function|Object} dependency - Dependency factory or instance
   * @param {Object} options - Registration options
   * @returns {void}
   */
  register(name, dependency, options = {}) {
    // Validate inputs
    if (!name || typeof name !== 'string') {
      throw new Error('Dependency name must be a non-empty string');
    }
    
    if (!dependency && typeof dependency !== 'function' && typeof dependency !== 'object') {
      throw new Error('Dependency must be a function or object');
    }
    
    // Check if already registered
    if (this.dependencies.has(name)) {
      if (!options.override) {
        throw new Error(\`Dependency '\${name}' is already registered\`);
      }
      this.log(\`‚ö†Ô∏è  Overriding dependency '\${name}'\`, 'warning');
    }
    
    // Validate dependencies if enforcement is enabled
    if (this.config.enforceDependencies) {
      this.validateDependencyRegistration(name, dependency, options);
    }
    
    // Store dependency
    this.dependencies.set(name, {
      factory: dependency,
      instance: null,
      options: {
        singleton: options.singleton || this.config.singletonPattern,
        lazy: options.lazy || this.config.lazyLoading,
        dependencies: options.dependencies || [],
        ...options
      }
    });
    
    // Update dependency graph
    this.updateDependencyGraph(name, options.dependencies || []);
    
    // Auto-register dependencies if enabled
    if (this.config.autoRegister && options.dependencies) {
      this.autoRegisterDependencies(name, options.dependencies);
    }
    
    this.log(\`‚úÖ Registered dependency: \${name}\`, 'info');
  }

  /**
   * Get a dependency instance
   * @param {string} name - Dependency name
   * @returns {*} Dependency instance
   */
  get(name) {
    // Check if dependency exists
    if (!this.dependencies.has(name)) {
      throw new Error(\`Dependency '\${name}' is not registered\`);
    }
    
    const dependency = this.dependencies.get(name);
    
    // Return singleton instance if applicable
    if (dependency.options.singleton && this.singletons.has(name)) {
      return this.singletons.get(name);
    }
    
    // Return cached instance if available
    if (this.config.enableCaching && this.cache.has(name)) {
      return this.cache.get(name);
    }
    
    // Create instance
    let instance;
    if (typeof dependency.factory === 'function') {
      // Inject dependencies
      const injectedDeps = this.injector.inject(dependency.options.dependencies);
      
      // Create instance with dependencies
      try {
        instance = dependency.factory(injectedDeps);
      } catch (error) {
        throw new Error(\`Failed to create instance of '\${name}': \${error.message}\`);
      }
    } else {
      // Use provided instance
      instance = dependency.factory;
    }
    
    // Cache instance
    if (this.config.enableCaching) {
      this.cache.set(name, instance);
    }
    
    // Store singleton
    if (dependency.options.singleton) {
      this.singletons.set(name, instance);
    }
    
    return instance;
  }

  /**
   * Check if dependency is registered
   * @param {string} name - Dependency name
   * @returns {boolean} True if registered
   */
  has(name) {
    return this.dependencies.has(name);
  }

  /**
   * Unregister a dependency
   * @param {string} name - Dependency name
   * @returns {boolean} True if unregistered successfully
   */
  unregister(name) {
    if (!this.dependencies.has(name)) {
      return false;
    }
    
    // Cleanup
    this.dependencies.delete(name);
    this.cache.delete(name);
    this.singletons.delete(name);
    
    this.log(\`üóëÔ∏è  Unregistered dependency: \${name}\`, 'info');
    return true;
  }

  /**
   * Clear all dependencies
   * @returns {void}
   */
  clear() {
    this.dependencies.clear();
    this.instances.clear();
    this.dependencyGraph.clear();
    this.registrationOrder = [];
    this.cache.clear();
    this.singletons.clear();
    
    this.log('üßπ Cleared all dependencies', 'info');
  }

  /**
   * Get all registered dependency names
   * @returns {Array} Array of dependency names
   */
  getRegisteredDependencies() {
    return Array.from(this.dependencies.keys());
  }

  /**
   * Get dependency graph
   * @returns {Object} Dependency graph object
   */
  getDependencyGraph() {
    const graph = {};
    for (const [name, deps] of this.dependencyGraph) {
      graph[name] = deps;
    }
    return graph;
  }

  /**
   * Validate dependency registration
   * @param {string} name - Dependency name
   * @param {*} dependency - Dependency factory or instance
   * @param {Object} options - Registration options
   * @returns {void}
   */
  validateDependencyRegistration(name, dependency, options) {
    // Check circular dependencies
    if (this.circularDetector.hasCircularDependency(name, options.dependencies)) {
      throw new Error(\`Circular dependency detected for '\${name}': \${this.circularDetector.getCircularPath().join(' -> ')}\`);
    }
    
    // Validate dependency factory
    if (typeof dependency.factory === 'function') {
      // Check function signature
      if (dependency.factory.length > 0 && !options.dependencies) {
        this.log(\`‚ö†Ô∏è  Factory for '\${name}' expects parameters but no dependencies provided\`, 'warning');
      }
    }
    
    // Run custom validators
    this.validators.validate(name, dependency, options);
  }

  /**
   * Auto-register dependencies
   * @param {string} parentName - Parent dependency name
   * @param {Array} dependencies - Array of dependency names
   * @returns {void}
   */
  autoRegisterDependencies(parentName, dependencies) {
    dependencies.forEach(dep => {
      if (!this.has(dep)) {
        this.log(\`‚ö†Ô∏è  Auto-registering missing dependency '\${dep}' for '\${parentName}'\`, 'warning');
        // This would typically be handled by configuration or module loading
      }
    });
  }

  /**
   * Update dependency graph
   * @param {string} name - Dependency name
   * @param {Array} dependencies - Array of dependency names
   * @returns {void}
   */
  updateDependencyGraph(name, dependencies) {
    this.dependencyGraph.set(name, dependencies);
    this.registrationOrder.push(name);
  }

  /**
   * Get registration statistics
   * @returns {Object} Registration statistics
   */
  getStats() {
    return {
      totalDependencies: this.dependencies.size,
      singletons: this.singletons.size,
      cached: this.cache.size,
      registrationOrder: this.registrationOrder,
      dependencyGraph: this.getDependencyGraph()
    };
  }
}

module.exports = DependencyRegistry;
`;

    await this.writeFile('src/core/DependencyRegistry.js', content);
  }

  /**
   * Generate dependency validator
   * @returns {Promise<void>}
   */
  async generateDependencyValidator() {
    const content = `/**
 * ‚ú® Dependency Validator
 * Validates dependency registrations and enforces rules
 * 
 * @generated by RevolutionaryCodegen
 */

class DependencyValidator {
  constructor() {
    this.rules = new Map();
    this.initializeDefaultRules();
  }

  /**
   * Initialize default validation rules
   * @returns {void}
   */
  initializeDefaultRules() {
    // Rule: Dependencies must exist
    this.addRule('dependencyExists', (name, dependency, options) => {
      if (options.dependencies) {
        for (const dep of options.dependencies) {
          if (typeof dep !== 'string') {
            throw new Error(\`Dependency '\${dep}' must be a string\`);
          }
        }
      }
      return true;
    });

    // Rule: Singleton consistency
    this.addRule('singletonConsistency', (name, dependency, options) => {
      if (options.singleton && typeof dependency.factory === 'function') {
        // Factory should be idempotent for singletons
        return true;
      }
      return true;
    });

    // Rule: Naming convention
    this.addRule('namingConvention', (name, dependency, options) => {
      if (!/^[A-Z][a-zA-Z0-9]*$/.test(name)) {
        throw new Error(\`Dependency name '\${name}' should follow PascalCase convention\`);
      }
      return true;
    });
  }

  /**
   * Add a validation rule
   * @param {string} name - Rule name
   * @param {Function} validator - Validator function
   * @returns {void}
   */
  addRule(name, validator) {
    this.rules.set(name, validator);
  }

  /**
   * Remove a validation rule
   * @param {string} name - Rule name
   * @returns {boolean} True if rule was removed
   */
  removeRule(name) {
    return this.rules.delete(name);
  }

  /**
   * Validate dependency with all rules
   * @param {string} name - Dependency name
   * @param {*} dependency - Dependency factory or instance
   * @param {Object} options - Registration options
   * @returns {void}
   */
  validate(name, dependency, options) {
    for (const [ruleName, rule] of this.rules) {
      try {
        rule(name, dependency, options);
      } catch (error) {
        throw new Error(\`Validation failed for '\${name}' (\${ruleName}): \${error.message}\`);
      }
    }
  }

  /**
   * Get all registered rules
   * @returns {Array} Array of rule names
   */
  getRules() {
    return Array.from(this.rules.keys());
  }
}

module.exports = DependencyValidator;
`;

    await this.writeFile('src/core/DependencyValidator.js', content);
  }

  /**
   * Generate circular dependency detector
   * @returns {Promise<void>}
   */
  async generateCircularDependencyDetector() {
    const content = `/**
 * üîÑ Circular Dependency Detector
 * Detects and prevents circular dependencies in the registry
 * 
 * @generated by RevolutionaryCodegen
 */

class CircularDependencyDetector {
  constructor() {
    this.visiting = new Set();
    this.visited = new Set();
    this.circularPaths = [];
  }

  /**
   * Check for circular dependencies
   * @param {string} name - Dependency name
   * @param {Array} dependencies - Array of dependency names
   * @returns {boolean} True if circular dependency exists
   */
  hasCircularDependency(name, dependencies = []) {
    // Reset tracking
    this.visiting.clear();
    this.visited.clear();
    this.circularPaths = [];
    
    // Start DFS traversal
    return this.detectCircular(name, dependencies);
  }

  /**
   * Get circular dependency path
   * @returns {Array} Circular dependency path
   */
  getCircularPath() {
    return this.circularPaths.length > 0 ? this.circularPaths[0] : [];
  }

  /**
   * Get all circular dependency paths
   * @returns {Array} Array of circular paths
   */
  getAllCircularPaths() {
    return this.circularPaths;
  }

  /**
   * Detect circular dependencies using DFS
   * @param {string} current - Current dependency
   * @param {Array} path - Current path
   * @returns {boolean} True if circular dependency found
   */
  detectCircular(current, dependencies, path = []) {
    // Check if we're currently visiting this node
    if (this.visiting.has(current)) {
      // Found circular dependency
      const circularPath = path.slice(path.indexOf(current));
      this.circularPaths.push([...circularPath, current]);
      return true;
    }
    
    // Check if already processed (no circular dependency found from this path)
    if (this.visited.has(current)) {
      return false;
    }
    
    // Mark as visiting
    this.visiting.add(current);
    path.push(current);
    
    // Recursively check dependencies
    if (dependencies && dependencies.length > 0) {
      for (const dep of dependencies) {
        // Get dependencies of current dependency (this would need the registry)
        // For this example, we'll simulate the check
        if (this.detectCircular(dep, [], path)) {
          this.visiting.delete(current);
          return true;
        }
      }
    }
    
    // Mark as visited and clean up
    this.visited.add(current);
    this.visiting.delete(current);
    path.pop();
    
    return false;
  }

  /**
   * Clear detection state
   * @returns {void}
   */
  clear() {
    this.visiting.clear();
    this.visited.clear();
    this.circularPaths = [];
  }
}

module.exports = CircularDependencyDetector;
`;

    await this.writeFile('src/core/CircularDependencyDetector.js', content);
  }

  /**
   * Generate dependency injector
   * @returns {Promise<void>}
   */
  async generateDependencyInjector() {
    const content = `/**
 * üíâ Dependency Injector
 * Handles runtime dependency injection
 * 
 * @generated by RevolutionaryCodegen
 */

class DependencyInjector {
  constructor(registry) {
    this.registry = registry;
    this.injectionCache = new Map();
  }

  /**
   * Inject dependencies into a factory function
   * @param {Array} dependencies - Array of dependency names
   * @returns {Object} Injected dependencies object
   */
  inject(dependencies = []) {
    const injected = {};
    
    for (const depName of dependencies) {
      injected[depName] = this.resolveDependency(depName);
    }
    
    return injected;
  }

  /**
   * Resolve a dependency with caching
   * @param {string} name - Dependency name
   * @returns {*} Resolved dependency
   */
  resolveDependency(name) {
    // Check cache first
    if (this.injectionCache.has(name)) {
      return this.injectionCache.get(name);
    }
    
    // Resolve from registry
    const dependency = this.registry.get(name);
    
    // Cache the resolution
    this.injectionCache.set(name, dependency);
    
    return dependency;
  }

  /**
   * Clear injection cache
   * @returns {void}
   */
  clearCache() {
    this.injectionCache.clear();
  }

  /**
   * Get injection statistics
   * @returns {Object} Injection statistics
   */
  getStats() {
    return {
      cacheSize: this.injectionCache.size,
      cachedDependencies: Array.from(this.injectionCache.keys())
    };
  }
}

module.exports = DependencyInjector;
`;

    await this.writeFile('src/core/DependencyInjector.js', content);
  }

  /**
   * Generate dependency graph visualizer
   * @returns {Promise<void>}
   */
  async generateDependencyGraphVisualizer() {
    const content = `/**
 * üìä Dependency Graph Visualizer
 * Creates visual representations of dependency graphs
 * 
 * @generated by RevolutionaryCodegen
 */

class DependencyGraphVisualizer {
  constructor(registry) {
    this.registry = registry;
  }

  /**
   * Generate DOT format for Graphviz
   * @returns {string} DOT format string
   */
  generateDOT() {
    const graph = this.registry.getDependencyGraph();
    let dot = 'digraph DependencyGraph {\\n';
    dot += '  rankdir=TB;\\n';
    dot += '  node [shape=box, style=filled, fillcolor=lightblue];\\n';
    
    // Add nodes and edges
    for (const [name, deps] of Object.entries(graph)) {
      // Add node
      dot += \`  "\${name}" [label="\${name}"];\\n\`;
      
      // Add edges
      deps.forEach(dep => {
        dot += \`  "\${name}" -> "\${dep}";\\n\`;
      });
    }
    
    dot += '}\\n';
    return dot;
  }

  /**
   * Generate Mermaid format
   * @returns {string} Mermaid format string
   */
  generateMermaid() {
    const graph = this.registry.getDependencyGraph();
    let mermaid = 'graph TD;\\n';
    
    // Add nodes and edges
    for (const [name, deps] of Object.entries(graph)) {
      deps.forEach(dep => {
        mermaid += \`  \${name} --> \${dep};\\n\`;
      });
    }
    
    return mermaid;
  }

  /**
   * Generate ASCII visualization
   * @returns {string} ASCII visualization
   */
  generateASCII() {
    const graph = this.registry.getDependencyGraph();
    const lines = [];
    
    for (const [name, deps] of Object.entries(graph)) {
      if (deps.length === 0) {
        lines.push(\`‚îú‚îÄ‚îÄ \${name} (no dependencies)\`);
      } else {
        lines.push(\`‚îú‚îÄ‚îÄ \${name}\`);
        deps.forEach(dep => {
          lines.push(\`‚îÇ   ‚îî‚îÄ‚îÄ \${dep}\`);
        });
      }
    }
    
    return lines.join('\\n');
  }

  /**
   * Export graph to file
   * @param {string} format - Export format (dot, mermaid, ascii)
   * @param {string} filename - Output filename
   * @returns {void}
   */
  exportToFile(format, filename) {
    let content;
    
    switch (format.toLowerCase()) {
      case 'dot':
        content = this.generateDOT();
        break;
      case 'mermaid':
        content = this.generateMermaid();
        break;
      case 'ascii':
        content = this.generateASCII();
        break;
      default:
        throw new Error(\`Unsupported format: \${format}\`);
    }
    
    const fs = require('fs');
    fs.writeFileSync(filename, content, 'utf8');
    
    console.log(\`üìä Dependency graph exported to \${filename} (\${format} format)\`);
  }
}

module.exports = DependencyGraphVisualizer;
`;

    await this.writeFile('src/core/DependencyGraphVisualizer.js', content);
  }

  /**
   * Generate dependency manager
   * @returns {Promise<void>}
   */
  async generateDependencyManager() {
    const content = `/**
 * üéØ Dependency Manager
 * High-level management of dependencies and lifecycle
 * 
 * @generated by RevolutionaryCodegen
 */

class DependencyManager {
  constructor() {
    this.registry = new DependencyRegistry();
    this.visualizer = new DependencyGraphVisualizer(this.registry);
    this.initialized = false;
  }

  /**
   * Initialize the dependency system
   * @returns {Promise<void>}
   */
  async initialize() {
    if (this.initialized) {
      return;
    }
    
    // Auto-register known dependencies
    await this.autoRegisterDependencies();
    
    // Validate all dependencies
    this.validateAllDependencies();
    
    // Export dependency graph
    if (process.env.EXPORT_DEPENDENCY_GRAPH) {
      this.visualizer.exportToFile('dot', 'dependency-graph.dot');
      this.visualizer.exportToFile('mermaid', 'dependency-graph.mmd');
    }
    
    this.initialized = true;
    console.log('‚úÖ Dependency system initialized');
  }

  /**
   * Auto-register dependencies from specification
   * @returns {Promise<void>}
   */
  async autoRegisterDependencies() {
    // This would typically load from project specification
    const dependencies = this.getDependencySpecification();
    
    for (const dep of dependencies) {
      try {
        this.registry.register(dep.name, dep.factory, dep.options);
      } catch (error) {
        console.error(\`Failed to register \${dep.name}: \${error.message}\`);
      }
    }
  }

  /**
   * Validate all registered dependencies
   * @returns {void}
   */
  validateAllDependencies() {
    const stats = this.registry.getStats();
    
    // Check for circular dependencies
    const circularDeps = this.visualizer.getAllCircularPaths();
    if (circularDeps.length > 0) {
      console.error('‚ùå Circular dependencies detected:');
      circularDeps.forEach((path, index) => {
        console.error(\`  \${index + 1}. \${path.join(' -> ')}\`);
      });
    }
    
    // Log statistics
    console.log('üìä Dependency Statistics:');
    console.log(\`  Total Dependencies: \${stats.totalDependencies}\`);
    console.log(\`  Singletons: \${stats.singletons}\`);
    console.log(\`  Cached: \${stats.cached}\`);
  }

  /**
   * Get dependency specification (placeholder)
   * @returns {Array} Dependency specifications
   */
  getDependencySpecification() {
    // This would typically come from project specification
    return [
      {
        name: 'BaseService',
        factory: () => new BaseService(),
        options: { singleton: true }
      },
      {
        name: 'BaseData',
        factory: () => new BaseData(),
        options: { singleton: false }
      }
    ];
  }

  /**
   * Get dependency registry instance
   * @returns {DependencyRegistry} Registry instance
   */
  getRegistry() {
    return this.registry;
  }

  /**
   * Get visualizer instance
   * @returns {DependencyGraphVisualizer} Visualizer instance
   */
  getVisualizer() {
    return this.visualizer;
  }

  /**
   * Cleanup dependency system
   * @returns {void}
   */
  cleanup() {
    this.registry.clear();
    this.initialized = false;
  }
}

module.exports = DependencyManager;
`;

    await this.writeFile('src/core/DependencyManager.js', content);
  }

  /**
   * Generate registration system
   * @returns {Promise<void>}
   */
  async generateRegistrationSystem() {
    const content = `/**
 * üìù Auto Registration System
 * Automatically registers classes with their dependencies
 * 
 * @generated by RevolutionaryCodegen
 */

class AutoRegistrationSystem {
  constructor(registry) {
    this.registry = registry;
    this.registrationQueue = [];
    this.processing = false;
  }

  /**
   * Queue a class for registration
   * @param {string} className - Class name
   * @param {Function} factory - Factory function
   * @param {Object} options - Registration options
   * @returns {void}
   */
  queueRegistration(className, factory, options = {}) {
    this.registrationQueue.push({
      className,
      factory,
      options,
      timestamp: Date.now()
    });
  }

  /**
   * Process all queued registrations
   * @returns {Promise<void>}
   */
  async processRegistrations() {
    if (this.processing || this.registrationQueue.length === 0) {
      return;
    }
    
    this.processing = true;
    
    // Sort by dependencies (register dependencies first)
    const sorted = this.sortByDependencies(this.registrationQueue);
    
    // Process registrations
    for (const registration of sorted) {
      try {
        await this.registerClass(registration);
      } catch (error) {
        console.error(\`Failed to register \${registration.className}: \${error.message}\`);
      }
    }
    
    // Clear queue
    this.registrationQueue = [];
    this.processing = false;
    
    console.log(\`‚úÖ Processed \${sorted.length} auto-registrations\`);
  }

  /**
   * Register a class with dependencies
   * @param {Object} registration - Registration object
   * @returns {Promise<void>}
   */
  async registerClass(registration) {
    const { className, factory, options } = registration;
    
    // Extract dependencies from factory if possible
    const dependencies = this.extractDependencies(factory);
    
    // Update options with dependencies
    const registrationOptions = {
      ...options,
      dependencies
    };
    
    // Register with dependency validation
    this.registry.register(className, factory, registrationOptions);
  }

  /**
   * Sort registrations by dependencies
   * @param {Array} registrations - Array of registrations
   * @returns {Array} Sorted array
   */
  sortByDependencies(registrations) {
    const sorted = [];
    const processed = new Set();
    
    const process = (registration) => {
      if (processed.has(registration.className)) {
        return;
      }
      
      // Process dependencies first
      const dependencies = this.extractDependencies(registration.factory);
      dependencies.forEach(dep => {
        const depReg = registrations.find(r => r.className === dep);
        if (depReg && !processed.has(dep)) {
          process(depReg);
        }
      });
      
      sorted.push(registration);
      processed.add(registration.className);
    };
    
    registrations.forEach(process);
    return sorted;
  }

  /**
   * Extract dependencies from factory function
   * @param {Function} factory - Factory function
   * @returns {Array} Array of dependency names
   */
  extractDependencies(factory) {
    // This would typically use reflection or static analysis
    // For now, return empty array (would be enhanced with actual parsing)
    return [];
  }

  /**
   * Get registration queue status
   * @returns {Object} Queue status
   */
  getQueueStatus() {
    return {
      queueLength: this.registrationQueue.length,
      processing: this.processing,
      queuedClasses: this.registrationQueue.map(r => r.className)
    };
  }

  /**
   * Clear registration queue
   * @returns {void}
   */
  clearQueue() {
    this.registrationQueue = [];
    this.processing = false;
  }
}

module.exports = AutoRegistrationSystem;
`;

    await this.writeFile('src/core/AutoRegistrationSystem.js', content);
  }

  /**
   * Generate caching system
   * @returns {Promise<void>}
   */
  async generateCachingSystem() {
    const content = `/**
 * üíæ Dependency Caching System
 * Provides intelligent caching for dependency instances
 * 
 * @generated by RevolutionaryCodegen
 */

class DependencyCache {
  constructor(options = {}) {
    this.cache = new Map();
    this.ttl = options.ttl || 300000; // 5 minutes default
    this.maxSize = options.maxSize || 1000;
    this.stats = {
      hits: 0,
      misses: 0,
      evictions: 0
    };
  }

  /**
   * Get a cached dependency
   * @param {string} key - Cache key
   * @returns {*} Cached dependency or undefined
   */
  get(key) {
    const item = this.cache.get(key);
    
    if (!item) {
      this.stats.misses++;
      return undefined;
    }
    
    // Check TTL
    if (Date.now() > item.expiresAt) {
      this.cache.delete(key);
      this.stats.evictions++;
      return undefined;
    }
    
    // Update access time
    item.lastAccessed = Date.now();
    this.stats.hits++;
    
    return item.value;
  }

  /**
   * Set a cached dependency
   * @param {string} key - Cache key
   * @param {*} value - Dependency to cache
   * @param {number} ttl - Time to live in ms
   * @returns {void}
   */
  set(key, value, ttl = this.ttl) {
    // Check cache size limit
    if (this.cache.size >= this.maxSize) {
      this.evictLeastRecentlyUsed();
    }
    
    const item = {
      value,
      createdAt: Date.now(),
      expiresAt: Date.now() + ttl,
      lastAccessed: Date.now()
    };
    
    this.cache.set(key, item);
  }

  /**
   * Check if key exists in cache
   * @param {string} key - Cache key
   * @returns {boolean} True if exists and not expired
   */
  has(key) {
    const item = this.cache.get(key);
    
    if (!item) {
      return false;
    }
    
    return Date.now() <= item.expiresAt;
  }

  /**
   * Delete a cached item
   * @param {string} key - Cache key
   * @returns {boolean} True if deleted
   */
  delete(key) {
    return this.cache.delete(key);
  }

  /**
   * Clear all cache
   * @returns {void}
   */
  clear() {
    this.cache.clear();
    this.stats = { hits: 0, misses: 0, evictions: 0 };
  }

  /**
   * Evict least recently used items
   * @returns {void}
   */
  evictLeastRecentlyUsed() {
    let oldestKey = null;
    let oldestTime = Date.now();
    
    for (const [key, item] of this.cache) {
      if (item.lastAccessed < oldestTime) {
        oldestTime = item.lastAccessed;
        oldestKey = key;
      }
    }
    
    if (oldestKey) {
      this.cache.delete(oldestKey);
      this.stats.evictions++;
    }
  }

  /**
   * Get cache statistics
   * @returns {Object} Cache statistics
   */
  getStats() {
    const hitRate = this.stats.hits + this.stats.misses > 0 
      ? (this.stats.hits / (this.stats.hits + this.stats.misses)) * 100 
      : 0;
    
    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      hits: this.stats.hits,
      misses: this.stats.misses,
      evictions: this.stats.evictions,
      hitRate: Math.round(hitRate * 100) / 100
    };
  }
}

module.exports = DependencyCache;
`;

    await this.writeFile('src/core/DependencyCache.js', content);
  }

  /**
   * Generate singleton manager
   * @returns {Promise<void>}
   */
  async generateSingletonManager() {
    const content = `/**
 * üèÜ Singleton Manager
 * Manages singleton instances with lifecycle control
 * 
 * @generated by RevolutionaryCodegen
 */

class SingletonManager {
  constructor() {
    this.singletons = new Map();
    this.creationLocks = new Map();
  }

  /**
   * Get or create a singleton instance
   * @param {string} name - Singleton name
   * @param {Function} factory - Factory function
   * @returns {Promise<*>} Singleton instance
   */
  async getInstance(name, factory) {
    // Return existing instance
    if (this.singletons.has(name)) {
      return this.singletons.get(name);
    }
    
    // Check if creation is in progress
    if (this.creationLocks.has(name)) {
      // Wait for creation to complete
      return await this.waitForCreation(name);
    }
    
    // Lock creation
    this.creationLocks.set(name, Promise.resolve());
    
    try {
      // Create new instance
      const instance = await factory();
      
      // Store singleton
      this.singletons.set(name, {
        instance,
        createdAt: Date.now(),
        accessCount: 0
      });
      
      return instance;
    } finally {
      // Release lock
      this.creationLocks.delete(name);
    }
  }

  /**
   * Wait for singleton creation
   * @param {string} name - Singleton name
   * @returns {Promise<*>} Singleton instance
   */
  async waitForCreation(name) {
    const lock = this.creationLocks.get(name);
    
    if (lock) {
      await lock;
    }
    
    return this.singletons.get(name)?.instance;
  }

  /**
   * Check if singleton exists
   * @param {string} name - Singleton name
   * @returns {boolean} True if exists
   */
  hasInstance(name) {
    return this.singletons.has(name);
  }

  /**
   * Get singleton instance (synchronous)
   * @param {string} name - Singleton name
   * @returns {*} Singleton instance or undefined
   */
  getInstanceSync(name) {
    const singleton = this.singletons.get(name);
    return singleton ? singleton.instance : undefined;
  }

  /**
   * Update singleton access count
   * @param {string} name - Singleton name
   * @returns {void}
   */
  recordAccess(name) {
    const singleton = this.singletons.get(name);
    if (singleton) {
      singleton.accessCount++;
      singleton.lastAccessed = Date.now();
    }
  }

  /**
   * Destroy a singleton
   * @param {string} name - Singleton name
   * @returns {boolean} True if destroyed
   */
  destroyInstance(name) {
    const singleton = this.singletons.get(name);
    if (!singleton) {
      return false;
    }
    
    // Call cleanup if available
    if (singleton.instance && typeof singleton.instance.destroy === 'function') {
      singleton.instance.destroy();
    }
    
    // Remove singleton
    this.singletons.delete(name);
    this.creationLocks.delete(name);
    
    return true;
  }

  /**
   * Get all singleton names
   * @returns {Array} Array of singleton names
   */
  getAllInstances() {
    return Array.from(this.singletons.keys());
  }

  /**
   * Get singleton statistics
   * @returns {Object} Singleton statistics
   */
  getStats() {
    const stats = {};
    
    for (const [name, singleton] of this.singletons) {
      stats[name] = {
        createdAt: singleton.createdAt,
        accessCount: singleton.accessCount,
        lastAccessed: singleton.lastAccessed
      };
    }
    
    return {
      totalSingletons: this.singletons.size,
      instances: stats
    };
  }

  /**
   * Clear all singletons
   * @returns {void}
   */
  clear() {
    // Destroy all instances
    for (const name of this.singletons.keys()) {
      this.destroyInstance(name);
    }
    
    this.singletons.clear();
    this.creationLocks.clear();
  }
}

module.exports = SingletonManager;
`;

    await this.writeFile('src/core/SingletonManager.js', content);
  }

  /**
   * Generate registry utilities
   * @returns {Promise<void>}
   */
  async generateRegistryUtilities() {
    const content = `/**
 * üõ†Ô∏è Registry Utilities
 * Helper utilities for dependency registry operations
 * 
 * @generated by RevolutionaryCodegen
 */

class RegistryUtils {
  /**
   * Analyze dependency graph for potential issues
   * @param {Object} graph - Dependency graph
   * @returns {Object} Analysis results
   */
  static analyzeGraph(graph) {
    const analysis = {
      totalNodes: Object.keys(graph).length,
      totalEdges: 0,
      maxDepth: 0,
      leafNodes: [],
      rootNodes: [],
      stronglyConnected: false
    };
    
    // Count edges and find root/leaf nodes
    for (const [node, deps] of Object.entries(graph)) {
      analysis.totalEdges += deps.length;
      
      if (deps.length === 0) {
        analysis.leafNodes.push(node);
      }
      
      // Check if any node depends on this one
      let hasIncoming = false;
      for (const [, nodeDeps] of Object.entries(graph)) {
        if (nodeDeps.includes(node)) {
          hasIncoming = true;
          break;
        }
      }
      
      if (!hasIncoming) {
        analysis.rootNodes.push(node);
      }
    }
    
    // Calculate maximum depth
    analysis.maxDepth = this.calculateMaxDepth(graph);
    
    return analysis;
  }

  /**
   * Calculate maximum dependency depth
   * @param {Object} graph - Dependency graph
   * @returns {number} Maximum depth
   */
  static calculateMaxDepth(graph, node = null, depth = 0, visited = new Set()) {
    let maxDepth = depth;
    
    if (node === null) {
      // Find all root nodes
      const roots = Object.keys(graph).filter(n => {
        return !Object.values(graph).some(deps => deps.includes(n));
      });
      
      for (const root of roots) {
        const rootDepth = this.calculateMaxDepth(graph, root, 0, new Set());
        maxDepth = Math.max(maxDepth, rootDepth);
      }
    } else {
      if (visited.has(node)) {
        return depth;
      }
      
      visited.add(node);
      const deps = graph[node] || [];
      
      for (const dep of deps) {
        const depDepth = this.calculateMaxDepth(graph, dep, depth + 1, new Set(visited));
        maxDepth = Math.max(maxDepth, depDepth);
      }
    }
    
    return maxDepth;
  }

  /**
   * Find all paths between two nodes
   * @param {Object} graph - Dependency graph
   * @param {string} start - Start node
   * @param {string} end - End node
   * @returns {Array} Array of paths
   */
  static findAllPaths(graph, start, end) {
    const paths = [];
    const visited = new Set();
    
    const dfs = (current, path) => {
      if (current === end) {
        paths.push([...path, end]);
        return;
      }
      
      if (visited.has(current)) {
        return;
      }
      
      visited.add(current);
      const deps = graph[current] || [];
      
      for (const dep of deps) {
        dfs(dep, [...path, current]);
      }
      
      visited.delete(current);
    };
    
    dfs(start, [start]);
    return paths;
  }

  /**
   * Find critical dependencies (bottlenecks)
   * @param {Object} graph - Dependency graph
   * @returns {Array} Array of critical dependencies
   */
  static findCriticalDependencies(graph) {
    const critical = [];
    const incoming = new Map();
    
    // Count incoming edges for each node
    for (const [, deps] of Object.entries(graph)) {
      for (const dep of deps) {
        incoming.set(dep, (incoming.get(dep) || 0) + 1);
      }
    }
    
    // Find nodes with high incoming edge count
    const threshold = Math.max(...Array.from(incoming.values()));
    
    for (const [node, count] of incoming) {
      if (count === threshold && count > 2) {
        critical.push({
          node,
          incomingCount: count,
          percentage: (count / Object.keys(graph).length) * 100
        });
      }
    }
    
    return critical.sort((a, b) => b.incomingCount - a.incomingCount);
  }
}

module.exports = RegistryUtils;
`;

    await this.writeFile('src/core/RegistryUtils.js', content);
  }

  /**
   * Build dependency graph from specification
   * @returns {Promise<void>}
   */
  async buildDependencyGraph() {
    if (!this.specification?.classes) {
      this.log('‚ö†Ô∏è  No class specifications found for dependency graph', 'warning');
      return;
    }
    
    // Build graph from all class types
    const allClasses = [
      ...(this.specification.classes.businessLogic || []),
      ...(this.specification.classes.factories || []),
      ...(this.specification.classes.dataClasses || [])
    ];
    
    for (const classSpec of allClasses) {
      const dependencies = classSpec.dependencies || [];
      this.dependencyGraph.set(classSpec.name, dependencies);
    }
    
    this.log(`üìä Built dependency graph with ${this.dependencyGraph.size} nodes`, 'success');
  }

  /**
   * Detect circular dependencies
   * @returns {Promise<void>}
   */
  async detectCircularDependencies() {
    if (this.dependencyGraph.size === 0) {
      return;
    }
    
    const visited = new Set();
    const recursionStack = new Set();
    const circularPaths = [];
    
    const detectCircular = (node, path = []) => {
      if (recursionStack.has(node)) {
        // Found circular dependency
        const circularPath = path.slice(path.indexOf(node));
        circularPaths.push([...circularPath, node]);
        return true;
      }
      
      if (visited.has(node)) {
        return false;
      }
      
      visited.add(node);
      recursionStack.add(node);
      path.push(node);
      
      const dependencies = this.dependencyGraph.get(node) || [];
      for (const dep of dependencies) {
        if (detectCircular(dep, path)) {
          break; // Stop at first circular dependency found
        }
      }
      
      recursionStack.delete(node);
      path.pop();
      return false;
    };
    
    // Check all nodes
    for (const node of this.dependencyGraph.keys()) {
      if (!visited.has(node)) {
        detectCircular(node);
      }
    }
    
    this.circularDependencies = circularPaths;
    
    if (circularPaths.length > 0) {
      this.log(`‚ö†Ô∏è  Detected ${circularPaths.length} circular dependencies`, 'warning');
      circularPaths.forEach((path, index) => {
        this.log(`   ${index + 1}. ${path.join(' -> ')}`, 'warning');
      });
    }
  }

  /**
   * Check if dependency graph should be generated
   * @returns {boolean} True if should generate
   */
  shouldGenerateDependencyGraph() {
    return this.dependencyConfig.dependencyGraph !== false;
  }

  /**
   * Check if caching should be enabled
   * @returns {boolean} True if caching should be enabled
   */
  shouldEnableCaching() {
    return this.dependencyConfig.registry?.caching !== false;
  }

  /**
   * Check if singleton pattern should be used
   * @returns {boolean} True if singleton should be used
   */
  shouldUseSingletonPattern() {
    return this.dependencyConfig.registry?.singletonPattern !== false;
  }

  /**
   * Check if lazy loading should be enabled
   * @returns {boolean} True if lazy loading should be enabled
   */
  shouldEnableLazyLoading() {
    return this.dependencyConfig.registry?.lazyLoading !== false;
  }

  /**
   * Initialize dependency configuration
   * @returns {void}
   */
  initializeDependencyConfig() {
    this.dependencyConfig = {
      enforceDependencies: true,
      autoRegister: true,
      dependencyGraph: true,
      circularDependencyCheck: true,
      registry: {
        singletonPattern: true,
        lazyLoading: true,
        caching: true
      },
      ...this.dependencyConfig
    };
  }

  /**
   * Load project specification
   * @returns {Promise<void>}
   */
  async loadSpecification() {
    try {
      if (fs.existsSync(this.options.specPath)) {
        const content = fs.readFileSync(this.options.specPath, 'utf8');
        this.specification = JSON.parse(content);
        this.log(`üìÇ Loaded specification from ${this.options.specPath}`, 'success');
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è  Failed to load specification: ${error.message}`, 'warning');
    }
  }
}

module.exports = DependencyRegistryGenerator;
