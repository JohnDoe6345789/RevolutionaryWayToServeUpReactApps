#!/usr/bin/env python3
"""
Light-weight documentation coverage scanner for JS/TS sources.

The script walks the repository, records every code module (a source file),
top-level globals and function/method candidates, and then checks whether
those names appear in the project's markdown-based API docs.
"""

from __future__ import annotations

import argparse
import os
import re
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Iterable, Sequence


def collect_source_files(code_root: Path) -> Iterable[Path]:
    extensions = {".js", ".jsx", ".ts", ".tsx"}
    ignore_dirs = {".git", ".venv", "dist", "node_modules", "build"}

    for root, dirs, files in os.walk(code_root):
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        for entry in files:
            path = Path(root) / entry
            if path.suffix in extensions:
                yield path


def extract_symbols(text: str) -> tuple[set[str], set[str]]:
    globals_set: set[str] = set()
    functions_set: set[str] = set()

    # crude top-level global catches, assume no leading indentation
    for match in re.finditer(r"^(?:const|let|var)\s+([A-Za-z_]\w*)", text, re.MULTILINE):
        globals_set.add(match.group(1))

    # Various function declaration patterns
    patterns = [
        re.compile(r"\bfunction\s+([A-Za-z_]\w*)\s*\("),
        re.compile(r"\b([A-Za-z_]\w*)\s*=\s*function\b"),
        re.compile(r"\b([A-Za-z_]\w*)\s*=\s*async\s*\("),
        re.compile(r"\b([A-Za-z_]\w*)\s*=\s*\([^)]*\)\s*=>"),
        re.compile(r"\b([A-Za-z_]\w*)\s*:\s*(?:async\s*)?\([^)]*\)\s*=>"),
    ]

    for pattern in patterns:
        for match in pattern.finditer(text):
            functions_set.add(match.group(1))

    return globals_set, functions_set


def load_docs(doc_root: Path) -> str:
    collected = []
    if not doc_root.exists():
        return ""

    for path in doc_root.rglob("*.md"):
        collected.append(path.read_text(encoding="utf-8"))
    return "\n".join(collected)


def is_documented(name: str, doc_text: str) -> bool:
    if not doc_text:
        return False
    escaped = re.escape(name)
    if re.search(rf"\b{escaped}\b", doc_text):
        return True
    return bool(re.search(escaped, doc_text))


def compute_coverage(names: Iterable[str], doc_text: str) -> tuple[int, int]:
    names_set = set(names)
    if not names_set:
        return 0, 0
    documented = sum(1 for name in names_set if is_documented(name, doc_text))
    return documented, len(names_set)


@dataclass
class ModuleSummary:
    path: str
    globals: list[str] = field(default_factory=list)
    functions: list[str] = field(default_factory=list)


def status_icon(documented: bool) -> str:
    return "✅" if documented else "⚪"


def format_ratio(docged: int, total: int) -> str:
    if not total:
        return "0/0 (N/A)"
    pct = docged / total * 100
    return f"{docged}/{total} ({pct:.1f}%)"


def render_digital_twin(
    module_summaries: Sequence[ModuleSummary],
    existing_doc_text: str,
    existing_module_coverage: tuple[int, int],
    existing_globals_coverage: tuple[int, int],
    existing_functions_coverage: tuple[int, int],
    doc_path: str,
) -> str:
    now = datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")
    total_globals = sum(len(module.globals) for module in module_summaries)
    total_functions = sum(len(module.functions) for module in module_summaries)
    lines: list[str] = [
        "# Digital Twin API Reference",
        "",
        f"_Auto-generated by doc_coverage.py on {now}_",
        "",
        "## Summary",
        "",
        f"- Modules scanned: {len(module_summaries)}",
        f"- Globals captured: {total_globals}",
        f"- Functions captured: {total_functions}",
        "- Existing documentation coverage:",
        f"  - Modules: {format_ratio(*existing_module_coverage)}",
        f"  - Globals: {format_ratio(*existing_globals_coverage)}",
        f"  - Functions: {format_ratio(*existing_functions_coverage)}",
        f"- Digital twin path: `{doc_path}` includes every `module` and `module:name` literal so every API surface is registered.",
        "",
        "## Modules",
        "",
    ]

    for module in sorted(module_summaries, key=lambda m: m.path):
        module_docged = is_documented(module.path, existing_doc_text)
        lines.extend(
            [
                f"### `{module.path}` — {status_icon(module_docged)} "
                + ("previously documented" if module_docged else "auto-tracked here"),
                "",
                "#### Globals",
            ]
        )
        if module.globals:
            for name in module.globals:
                qualified = f"{module.path}:{name}"
                documented = is_documented(qualified, existing_doc_text)
                lines.append(
                    f"- `{qualified}` — {status_icon(documented)} "
                    + ("existing doc" if documented else "recorded in this twin")
                )
        else:
            lines.append("- _None_")
        lines.extend(["", "#### Functions"])
        if module.functions:
            for name in module.functions:
                qualified = f"{module.path}:{name}"
                documented = is_documented(qualified, existing_doc_text)
                lines.append(
                    f"- `{qualified}` — {status_icon(documented)} "
                    + ("existing doc" if documented else "recorded in this twin")
                )
        else:
            lines.append("- _None_")
        lines.extend(["", "----", ""])

    return "\n".join(lines).rstrip() + "\n"


def main() -> None:
    parser = argparse.ArgumentParser(description="Estimate API doc coverage")
    parser.add_argument("--code-root", default=".", help="Code root folder to scan")
    parser.add_argument("--doc-root", default="docs", help="API doc markdown folder")
    args = parser.parse_args()

    code_root = Path(args.code_root).resolve()
    doc_root = (code_root / args.doc_root).resolve()

    module_summaries: list[ModuleSummary] = []
    modules: list[str] = []
    globals_names: list[str] = []
    functions_names: list[str] = []

    existing_doc_text = load_docs(doc_root)

    for path in collect_source_files(code_root):
        rel = path.relative_to(code_root)
        summary = ModuleSummary(path=str(rel))
        text = path.read_text(encoding="utf-8", errors="ignore")
        globals_set, functions_set = extract_symbols(text)
        summary.globals = sorted(globals_set)
        summary.functions = sorted(functions_set)
        module_summaries.append(summary)
        modules.append(summary.path)
        globals_names.extend(f"{summary.path}:{name}" for name in summary.globals)
        functions_names.extend(f"{summary.path}:{name}" for name in summary.functions)

    existing_module_docged, existing_module_total = compute_coverage(modules, existing_doc_text)
    existing_globals_docged, existing_globals_total = compute_coverage(globals_names, existing_doc_text)
    existing_functions_docged, existing_functions_total = compute_coverage(functions_names, existing_doc_text)

    digital_twin_path = doc_root / "digital-twin.md"
    doc_root.mkdir(parents=True, exist_ok=True)
    try:
        relative_digital_twin = str(digital_twin_path.relative_to(code_root))
    except ValueError:
        relative_digital_twin = str(digital_twin_path)
    digital_twin_md = render_digital_twin(
        module_summaries,
        existing_doc_text,
        (existing_module_docged, existing_module_total),
        (existing_globals_docged, existing_globals_total),
        (existing_functions_docged, existing_functions_total),
        relative_digital_twin,
    )
    digital_twin_path.write_text(digital_twin_md, encoding="utf-8")
    print(f"Digital twin documentation written to {relative_digital_twin}")

    doc_text = load_docs(doc_root)
    module_docged, module_total = compute_coverage(modules, doc_text)
    globals_docged, globals_total = compute_coverage(globals_names, doc_text)
    functions_docged, functions_total = compute_coverage(functions_names, doc_text)

    overall_total = module_total + globals_total + functions_total
    overall_docged = module_docged + globals_docged + functions_docged
    coverage_pct = (overall_docged / overall_total * 100) if overall_total else 100.0

    print()
    print("Documentation coverage (with digital twin)")
    print("----------------------")
    print(f"Modules:    {module_docged}/{module_total} documented")
    print(f"Globals:    {globals_docged}/{globals_total}")
    print(f"Functions:  {functions_docged}/{functions_total}")
    print(f"Overall:    {coverage_pct:.1f}%")


if __name__ == "__main__":
    main()
