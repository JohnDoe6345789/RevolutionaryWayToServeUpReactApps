{
  "methods": {
    "loadModule": [
      "/**",
      " * Loads a module dynamically from the specified path or URL",
      " * Supports both local file system modules and remote CDN modules",
      " *",
      " * @async",
      " * @param {string|Object} moduleIdentifier - Module path, URL, or module spec",
      " * @param {Object} [options] - Loading options",
      " * @param {boolean} [options.cache=true] - Whether to cache loaded modules",
      " * @param {number} [options.timeout=30000] - Load timeout in milliseconds",
      " * @returns {Promise<Object>} Loaded module instance",
      " * @throws {Error} If module loading fails",
      " */",
      "async loadModule(moduleIdentifier, options = {}) {",
      "  if (!this._initialized) {",
      "    throw new Error('ModuleLoader must be initialized before loading modules');",
      "  }",
      "",
      "  try {",
      "    const modulePath = typeof moduleIdentifier === 'string' ? moduleIdentifier : moduleIdentifier.path;",
      "    const resolvedPath = await this.resolvePath(modulePath);",
      "",
      "    // Check cache first",
      "    if (options.cache !== false && this._moduleCache[resolvedPath]) {",
      "      return this._moduleCache[resolvedPath];",
      "    }",
      "",
      "    const module = await this._loadModuleInternal(resolvedPath, options);",
      "",
      "    // Cache the loaded module",
      "    if (options.cache !== false) {",
      "      this._moduleCache[resolvedPath] = module;",
      "    }",
      "",
      "    return module;",
      "  } catch (error) {",
      "    throw new Error(`Failed to load module ${moduleIdentifier}: ${error.message}`);",
      "  }",
      "}"
    ],
    "resolvePath": [
      "/**",
      " * Resolves a module path to an absolute path or URL",
      " * Handles relative paths, aliases, and protocol detection",
      " *",
      " * @param {string} modulePath - Module path to resolve",
      " * @returns {Promise<string>} Resolved absolute path or URL",
      " */",
      "async resolvePath(modulePath) {",
      "  if (!modulePath || typeof modulePath !== 'string') {",
      "    throw new Error('Invalid module path provided');",
      "  }",
      "",
      "  // Handle absolute paths and URLs",
      "  if (path.isAbsolute(modulePath) || modulePath.startsWith('http')) {",
      "    return modulePath;",
      "  }",
      "",
      "  // Resolve relative to configured base paths",
      "  const basePaths = this.spec.basePaths || [__dirname];",
      "  for (const basePath of basePaths) {",
      "    const resolvedPath = path.resolve(basePath, modulePath);",
      "    if (await this._pathExists(resolvedPath)) {",
      "      return resolvedPath;",
      "    }",
      "  }",
      "",
      "  throw new Error(`Module path could not be resolved: ${modulePath}`);",
      "}"
    ],
    "validateModule": [
      "/**",
      " * Validates that a module meets the required specifications",
      " * Checks interface compliance, dependencies, and basic functionality",
      " *",
      " * @param {Object} module - Module to validate",
      " * @param {Object} [requirements] - Validation requirements",
      " * @returns {Promise<boolean>} True if module is valid",
      " */",
      "async validateModule(module, requirements = {}) {",
      "  if (!module || typeof module !== 'object') {",
      "    return false;",
      "  }",
      "",
      "  // Check required methods",
      "  if (requirements.methods) {",
      "    for (const method of requirements.methods) {",
      "      if (typeof module[method] !== 'function') {",
      "        return false;",
      "      }",
      "    }",
      "  }",
      "",
      "  // Check required properties",
      "  if (requirements.properties) {",
      "    for (const prop of requirements.properties) {",
      "      if (!(prop in module)) {",
      "        return false;",
      "      }",
      "    }",
      "  }",
      "",
      "  return true;",
      "}"
    ],
    "discoverPlugins": [
      "/**",
      " * Discovers available plugins from configured directories",
      " * Scans plugin directories and validates plugin configurations",
      " *",
      " * @async",
      " * @param {Object} [options] - Discovery options",
      " * @param {Array<string>} [options.directories] - Directories to scan",
      " * @param {Array<string>} [options.patterns] - File patterns to match",
      " * @returns {Promise<Array<Object>>} Array of discovered plugin specifications",
      " */",
      "async discoverPlugins(options = {}) {",
      "  const directories = options.directories || this.spec.pluginDirectories || ['./plugins'];",
      "  const patterns = options.patterns || ['plugin.json', 'spec.json'];",
      "",
      "  const discoveredPlugins = [];",
      "",
      "  for (const directory of directories) {",
      "    try {",
      "      const plugins = await this._scanDirectory(directory, patterns);",
      "      discoveredPlugins.push(...plugins);",
      "    } catch (error) {",
      "      console.warn(`Warning: Failed to scan directory ${directory}: ${error.message}`);",
      "    }",
      "  }",
      "",
      "  return discoveredPlugins;",
      "}"
    ],
    "loadPlugin": [
      "/**",
      " * Loads a plugin by its specification",
      " * Initializes the plugin and registers it with the system",
      " *",
      " * @async",
      " * @param {Object} pluginSpec - Plugin specification",
      " * @param {Object} [context] - Loading context",
      " * @returns {Promise<Object>} Loaded plugin instance",
      " * @throws {Error} If plugin loading fails",
      " */",
      "async loadPlugin(pluginSpec, context = {}) {",
      "  if (!pluginSpec || !pluginSpec.id) {",
      "    throw new Error('Invalid plugin specification provided');",
      "  }",
      "",
      "  try {",
      "    const pluginModule = await this._loadPluginModule(pluginSpec);",
      "    const pluginInstance = new pluginModule(pluginSpec);",
      "",
      "    await pluginInstance.initialise();",
      "    await this.registerPlugin(pluginInstance, context);",
      "",
      "    return pluginInstance;",
      "  } catch (error) {",
      "    throw new Error(`Failed to load plugin ${pluginSpec.id}: ${error.message}`);",
      "  }",
      "}"
    ],
    "registerPlugin": [
      "/**",
      " * Registers a plugin with the system",
      " * Makes the plugin available for use and updates system state",
      " *",
      " * @async",
      " * @param {Object} plugin - Plugin instance to register",
      " * @param {Object} [context] - Registration context",
      " * @returns {Promise<void>}",
      " */",
      "async registerPlugin(plugin, context = {}) {",
      "  if (!plugin || !plugin.spec || !plugin.spec.id) {",
      "    throw new Error('Invalid plugin instance provided');",
      "  }",
      "",
      "  const pluginId = plugin.spec.id;",
      "",
      "  // Check for duplicate registration",
      "  if (this._registeredPlugins[pluginId]) {",
      "    throw new Error(`Plugin ${pluginId} is already registered`);",
      "  }",
      "",
      "  // Register the plugin",
      "  this._registeredPlugins[pluginId] = plugin;",
      "",
      "  // Execute plugin registration hook if available",
      "  if (typeof plugin.onRegister === 'function') {",
      "    await plugin.onRegister(context);",
      "  }",
      "}"
    ],
    "register": [
      "/**",
      " * Registers a service in the DI container",
      " *",
      " * @param {string} name - Service name",
      " * @param {Function|Object} implementation - Service implementation",
      " * @param {string} [lifetime='transient'] - Service lifetime",
      " */",
      "register(name, implementation, lifetime = 'transient') {",
      "  // Implementation for service registration",
      "  throw new Error('register method not implemented');",
      "}"
    ],
    "resolve": [
      "/**",
      " * Resolves a service from the DI container",
      " *",
      " * @param {string} name - Service name",
      " * @returns {*} Resolved service instance",
      " */",
      "resolve(name) {",
      "  // Implementation for service resolution",
      "  throw new Error('resolve method not implemented');",
      "}"
    ],
    "inject": [
      "/**",
      " * Injects dependencies into a target object",
      " *",
      " * @param {Object} target - Target object",
      " * @param {Array<string>} dependencies - Dependency names",
      " */",
      "inject(target, dependencies) {",
      "  // Implementation for dependency injection",
      "  throw new Error('inject method not implemented');",
      "}"
    ],
    "createRegistry": [
      "/**",
      " * Creates a new component registry",
      " *",
      " * @param {string} name - Registry name",
      " * @param {Object} [config] - Registry configuration",
      " * @returns {Object} Created registry",
      " */",
      "createRegistry(name, config = {}) {",
      "  // Implementation for registry creation",
      "  throw new Error('createRegistry method not implemented');",
      "}"
    ],
    "registerComponent": [
      "/**",
      " * Registers a component in the registry",
      " *",
      " * @param {Object} component - Component to register",
      " * @param {Object} [metadata] - Component metadata",
      " */",
      "registerComponent(component, metadata = {}) {",
      "  // Implementation for component registration",
      "  throw new Error('registerComponent method not implemented');",
      "}"
    ],
    "resolveComponent": [
      "/**",
      " * Resolves a component from the registry",
      " *",
      " * @param {string|Object} criteria - Resolution criteria",
      " * @returns {Object} Resolved component",
      " */",
      "resolveComponent(criteria) {",
      "  // Implementation for component resolution",
      "  throw new Error('resolveComponent method not implemented');",
      "}"
    ],
    "loadConfig": [
      "/**",
      " * Loads configuration from a source",
      " *",
      " * @async",
      " * @param {string|Object} source - Configuration source",
      " * @param {Object} [schema] - Validation schema",
      " * @returns {Promise<Object>} Loaded configuration",
      " */",
      "async loadConfig(source, schema) {",
      "  // Implementation for configuration loading",
      "  throw new Error('loadConfig method not implemented');",
      "}"
    ],
    "validateConfig": [
      "/**",
      " * Validates configuration against a schema",
      " *",
      " * @param {Object} config - Configuration object",
      " * @param {Object} schema - Validation schema",
      " * @returns {boolean} True if valid",
      " */",
      "validateConfig(config, schema) {",
      "  // Implementation for configuration validation",
      "  throw new Error('validateConfig method not implemented');",
      "}"
    ],
    "getSetting": [
      "/**",
      " * Retrieves a configuration setting",
      " *",
      " * @param {string} path - Setting path",
      " * @param {*} [defaultValue] - Default value if not found",
      " * @returns {*} Setting value",
      " */",
      "getSetting(path, defaultValue) {",
      "  // Implementation for setting retrieval",
      "  throw new Error('getSetting method not implemented');",
      "}"
    ]
  },
  "defaultMethod": [
    "/**",
    " * {methodName} - Module method (implementation required)",
    " * This is a placeholder implementation that should be overridden",
    " *",
    " * @param {...*} args - Method arguments",
    " * @returns {*} Method result",
    " * @throws {Error} Always throws - method not implemented",
    " */",
    "async {methodName}(...args) {",
    "  throw new Error(`{methodName} method not implemented in ${this.constructor.name}`);",
    "}"
  ]
}
